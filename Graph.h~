#ifndef GRAPH_H
#define GRAPH_H

#include "Edges.h"
#include "Vertex.h"
#include <vector>
using namespace std;
template <class T>
class Graph{
 public: 
  Graph() {
    directed = false; 
}
  Graph(bool directed) {
    this->directed = directed;
}
  ~Graph() {
  delete v;
  delete v1; 
  delete v2; 
  delete E;
}
 void newVertex(T val) {
   v = new Vertex<T>(val); 
   vertexArr.push_back(*v); 
 
}
 void newEdge(T a, T b) {
   v1 = new Vertex<T>(a); 
   v2 = new Vertex<T>(b); 
   int test = searchVerts(*v1, *v2);
   int loc1, loc2; 
   switch(test) {
   case 0: 
     std::cout << "ERROR" << std::endl; 
     
     break; 
   case 1: 
     loc2 = findVertex(v2);
     v2 = &(vertexArr[loc2]);\
     vertexArr.push_back(*v1); 
     break; 
   case 2: 
     loc1 = findVertex(v1);
     v1 = &(vertexArr[loc1]); 
     vertexArr.push_back(*v2); 
     break; 
   default: 
     vertexArr.push_back(*v1); 
     vertexArr.push_back(*v2); 
     std::cout << "ERROR!" << std::endl;
   }
     
   E = new Edges<T> (*v1, *v2);
   v1->incIn(); 
   v2->incIn();
   vertexArr.push_back(*v1); 
   vertexArr.push_back(*v2);
   edgeArr.push_back(*E);
   //delete v1; 
   //delete v2; 
   //delete E; 
}
 int findVertex(Vertex <T> * v) {
   for (int i = 0; i < vertexArr.size(); i++) 
     if (vertexArr[i] == *v)
       return i;
}

 int searchVerts(Vertex <T> a, Vertex <T> b) {
   bool aExists = false; 
   bool bExists = false;
   std::cout << vertexArr.size(); 
   for (int i = 0; i < vertexArr.size(); i++) {
     if (vertexArr[i] == a)
       aExists = true;
     if (vertexArr[i] == b)
       bExists = true;
   }
   if (aExists && bExists)
     return 0; 
   if (bExists && !aExists)
     return 1; 
   if (aExists && !bExists) 
     return 2;
}
 /*
searchVerts(T a, T b) {
  1. First, search for A in edge array. 
     If found: 
        a) look for B in edge array. If not found, 
	return A and create a new edge A->B
	b) If B is found
	   1. If B is in the same edge as A, check to see if 
	   multiple edges are allowed. If not, ignore. 
	   2. If in different edges, createa  new edge A->B, creating a cycle. 
     If not found: 
        b) Look for B in edge array. If not found, create a brand new edge a->b (disconnected) 
	c) If found, return the location of B and create a new edge a->b
} 
  */
 void readEdgeArr() {
   for (int i = 0; i < edgeArr.size(); i++)
       cout << edgeArr[i] << endl;
     }
 void readvertArr() {
   for (int i = 0; i < vertexArr.size(); i++)
     std:: cout << vertexArr[i] << endl;
 }

 private: 
  bool directed;
  std::vector <Vertex<T> > vertexArr; 
  std::vector <Edges<T> > edgeArr;
  Vertex <T> *v, *v1, *v2; 
  Edges <T> *E;
};

#endif
